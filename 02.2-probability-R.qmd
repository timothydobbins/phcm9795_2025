### Producing a one-way frequency table

We have three categorical variables to summarise in Table 1: sex, stage and vital status. These variables are best summarised using one-way frequency tables, which can be constructed using the `descriptives` function from the `jmv` package, with the `freq = TRUE` option. Before constructing frequency tables however, we *must define the variables as categorical variables*, by converting them to *factors*.

#### Defining categorical variables as factors {#sec-cat-as-factors}

To define a categorical variable as such in R, we define it as a **factor** using the factor function:

`factor(variable=, levels=, labels=)`

We specify:

-   levels: the values the categorical variable can take
-   labels: the labels corresponding to each of the levels (entered in the same order as the levels)

To define our variable `sex` as a factor, we use:

```{r}
pbc <- readRDS("data/activities/mod01_pbc.rds")

pbc$sex <- factor(pbc$sex,
    levels = c(1, 2),
    labels = c("Male", "Female")
)
```

We can then produce a frequency table:

```{r}
descriptives(data = pbc, vars = sex, freq = TRUE)
```

> Task: define `stage` and `status` (Vital Status) as factors, and produce one-way frequency tables. Refer to the file `pbc_info.txt` to view the labels for each variable. For example, for Stage:

```{r}
pbc$stage <- factor(pbc$stage,
    levels = c(1, 2, 3, 4),
    labels = c("Stage 1", "Stage 2", "Stage 3", "Stage 4")
)
```

### Producing a two-way frequency table

To produce tables summarising two categorical variables, we can use the `contTables()` function within the `jmv` package. The minimal inputs to include are `data`: the name of the data frame to be analysed, `rows`: the variable representing the rows of the table, and `cols`: the name of the columns of the table.

For example, to produce a two-way table showing stage of disease by sex using the pbc data frame, we use:

```{r}
contTables(data = pbc, rows = sex, cols = stage)
```

[The bottom part of the output, χ² Tests, can be ignored for now]

You may notice in the above that the number of observations is now 412. This is because there are missing observations for either sex or stage: which is it, and how would you determine this?

From the cross-tabulation, you can see the individual frequencies of participants in each of the categories in each cell. For example, there are 3 male participants who have Stage 1 disease. You can also read the totals for each row and column. For example, there are 44 males, and 144 participants have Stage 4 disease.

You can also add percentages into your table using `pcCol=TRUE` to include column percents, and `pcRow=TRUE` for row percents. For example, to calculate the relative frequencies (i.e. percentages) of sex within each stage, we would request **column percents** with the option: `pcCol=TRUE`.

```{r}
contTables(data = pbc, rows = sex, cols = stage, pcCol = TRUE)
```

We can see that the 3 male participants with Stage 1 disease represent 14% of those with Stage 1 disease.

## Creating bar charts for one categorical variable

The simplest way to use the `plot()` function is by specifying an object to be plotted. To plot a single variable from a data frame, we must define it using: `dataframe$variable`.

Here we will create the bar chart shown in @fig-bar-1 of the statistics notes using the `mod01_pdc.rds` dataset. The x-axis of this graph will be the stage of disease, and the y-axis will show the number of participants in each category.

```{r}
plot(pbc$stage,
    main = "Bar graph of stage of disease from PBC study",
    ylab = "Number of participants"
)
```

Note that stage is a categorical variable, that has been defined as a factor (in @sec-cat-as-factors). You **must define categorical data as factors** to plot them in a bar graph.

## Creating bar charts for two categorical variables

Creating a **clustered bar chart** as shown in @fig-bar-2 can be done easily using the `contTables` function in the `jmv` package. First create a cross-tab from the variables to be plotted, for example, Stage by Sex:

```{r}
contTables(data=pbc, rows=sex, cols=stage)
```


Creating a **clustered bar chart** as shown in @fig-bar-2 can be done by requesting a bar chart (`barplot=TRUE`), and the x-axis should be constructed from `stage` - that is, the **column** variable:

```{r}
contTables(pbc, rows=sex, cols=stage,
           barplot = TRUE, xaxis = "xcols")
```

If you want the x-axis to be constructed from the row variable, you would use `xaxis = "xrows"`.

To create a **stacked bar chart** (as in @fig-bar-3), specify `bartype` to be `stack`:

```{r}
contTables(pbc, rows=sex, cols=stage,
           barplot = TRUE, xaxis = "xcols", bartype ="stack")
```

Finally, to create a **stacked relative bar chart** (as in @fig-bar-4), specify the y-axis to be a percent (`yaxis="ypc"`), and the percentage be calculated from the columns of the frequency table (`yaxisPc = "column_pc"`):

```{r}
contTables(pbc, rows=sex, cols=stage,
           barplot = TRUE, bartype ="stack", xaxis = "xcols",
           yaxis = "ypc", yaxisPc = "column_pc")
```


## Importing data into R

We have described previously how to import data that have been saved as R .rds files. It is quite common to have data saved in other file types, such as Microsoft Excel, or plain text files. In this section, we will demonstrate how to import data from other packages into R.

There are two useful packages for importing data into R: `haven` (for data that have been saved by Stata, SAS or SPSS) and `readxl` (for data saved by Microsoft Excel). Additionally, the `labelled` package is useful in working with data that have been labelled in Stata.

### Importing plain text data into R

A `csv` file, or a "comma separated variables" file is commonly used to store data. These files have a very simple structure: they are plain text files, where data are separated by commas. csv files have the advantage that, as they are plain text files, they can be opened by a large number of programs (such as Notepad in Windows, TextEdit in MacOS, Microsoft Excel - even Microsoft Word). While they can be opened by Microsoft Excel, they can be opened by many other programs: the csv file can be thought of as the lingua-franca of data.

In this demonstration, we will use data on the weight of 1000 people entered in a csv file called `mod02_weight_1000.csv` available on Moodle.

To confirm that the file is readable by any text editor, here are the first ten lines of the file, opened in Notepad on Microsoft Windows, and TextEdit on MacOS.

```{r , echo=FALSE, out.width = "66%",}
knitr::include_graphics("img/mod02/import-01.png")
```

We can use the `read.csv` function:

```{r}
sample <- read.csv("data/examples/mod02_weight_1000.csv")
```

Here, the `read.csv` function has the default that the first row of the dataset contains the variable names. If your data do not have column names, you can use `header=FALSE` in the function.

Note: there is an alternative function `read_csv` which is part of the `readr` package (a component of the `tidyverse`). Some would argue that the `read_csv` function is more appropriate to use because of an issue known as `strings.as.factors`. The `strings.as.factors` default was removed in R Version 4.0.0, so it is less important which of the two functions you use to import a `.csv` file. More information about this issue can be found [here](https://simplystatistics.org/posts/2015-07-24-stringsasfactors-an-unauthorized-biography) and [here](https://developer.r-project.org/Blog/public/2020/02/16/stringsasfactors/).

<!-- ## Importing Excel data into R -->

<!-- Another common type of file that data are stored in is a Microsoft Excel file (.xls or .xlsx). In this demonstration, we will import a selection of records from a large health survey, stored in the file `mod02_health_survey.xlsx`. -->

<!-- The health survey data contains 1140 records, comprising: -->

<!-- -   sex: 1 = respondent identifies as male; 2 = respondent identifies as female -->
<!-- -   height: height in meters -->
<!-- -   weight: weight in kilograms -->

<!-- To import data from Microsoft Excel, we can use the `read_excel()` function in the `readxl` package. -->

<!-- ```{r} -->
<!-- library(readxl) -->

<!-- survey <- read_excel("data/examples/mod02_health_survey.xlsx") -->
<!-- summary(survey) -->
<!-- ``` -->

<!-- We can see that sex has been entered as a numeric variable. We should transform it into a factor so that we can assign labels to each category: -->

<!-- ```{r} -->
<!-- survey$sex <- factor(survey$sex, level = c(1, 2), labels = c("Male", "Female")) -->

<!-- summary(survey$sex) -->
<!-- ``` -->

<!-- We also note that height looks like it has been entered as meters, and weight as kilograms. -->

<!-- ## Generating new variables -->

<!-- Our health survey data contains information on height and weight. We often summarise body size using BMI: body mass index which is calculated as: $\frac{\text{weight (kg)}}{(\text{height (m)})^2}$ -->

<!-- We can create a new column in our data frame in many ways, such as using the following approach: -->

<!-- `dataframe$new_column <- <formula>` -->

<!-- For example: -->

<!-- ```{r} -->
<!-- survey$bmi <- survey$weight / (survey$height^2) -->
<!-- ``` -->

<!-- We should check the construction of the new variable by examining some records. The `head()` and `tail()` functions list the first and last 6 records in any dataset. We can also examine a histogram and boxplot: -->

<!-- ```{r} -->
<!-- head(survey) -->
<!-- tail(survey) -->

<!-- hist(survey$bmi) -->
<!-- boxplot(survey$bmi) -->
<!-- ``` -->

<!-- In the general population, BMI ranges between about 15 to 30. It appears that BMI has been correctly generated in this example. We should investigate the very low and some of the very high values of BMI, but this will be left for another time. -->

<!-- ## Summarising data by another variable -->

<!-- We will often want to calculate the same summary statistics by another variable. For example, we might want to calculate summary statistics for BMI for males and females separately. We can do this in in the `descriptives` function by defining sex as a `splitBy` variable: -->

<!-- ```{r} -->
<!-- library(jmv) -->
<!-- descriptives(data = survey, vars = bmi, splitBy = sex) -->
<!-- ``` -->

<!-- ## Summarising a single column of data -->

<!-- In Module 1, we started with a very simple analysis: reading in six ages, and them using `summary()` to calculate descriptive statistics. We then went on to use the `decriptives()` function in the `jmv` package as more flexible way of calculating descriptive statistics. Let's revisit this analysis: -->

<!-- ```{r message=FALSE, warning=FALSE, include=FALSE} -->
<!-- detach(package:jmv, unload = TRUE) -->
<!-- ``` -->


<!-- ```{r, error=TRUE} -->
<!-- # Author: Timothy Dobbins -->
<!-- # Date: 5 April 2022 -->
<!-- # Purpose: My first R script -->
<!-- library(jmv) -->

<!-- age <- c(20, 25, 23, 29, 21, 27) -->

<!-- # Use "summary" to obtain descriptive statistics -->
<!-- summary(age) -->

<!-- # Use the "descriptives" function from jmv to obtain descriptive statistics -->
<!-- descriptives(age) -->
<!-- ``` -->

<!-- The `summary()` function has worked correctly, but the `descriptives()` function has given an error: `Error: Argument 'data' must be a data frame`. What on earth is going on here? -->

<!-- The error gives us a clue here - the `descriptives()` function requires a data frame for analysis. We have provided the object `age`: a **vector**. As we saw in @sec-data-structures, a vector is a single column of data, while a data frame is a collection of columns. -->

<!-- In order to summarise a vector using the `descriptives()` function, we must first convert the vector into a data frame using `as.data.frame()`. For example: -->

<!-- ```{r} -->
<!-- # Author: Timothy Dobbins -->
<!-- # Date: 5 April 2024 -->
<!-- # Purpose: My first R script -->
<!-- library(jmv) -->

<!-- age <- c(20, 25, 23, 29, 21, 27) -->

<!-- # Use "summary" to obtain descriptive statistics -->
<!-- summary(age) -->

<!-- # Create a new data frame from the vector age: -->

<!-- age_df <- as.data.frame(age) -->

<!-- # Use "descriptives" to obtain descriptive statistics for age_df -->
<!-- descriptives(age_df) -->
<!-- ``` -->


<!-- ## Plotting data by another variable -->

<!-- Unfortunately, it is not straight-forward to create separate plots for every level of another variable. We will demonstrate by plotting BMI by sex using our health survey data. -->

<!-- The following steps are not the most efficient way of doing this, but are easy to follow and understand. We first begin by creating two new data frames, for males and females separately, using the `subset()` function: -->

<!-- ```{r} -->
<!-- survey_males <- subset(survey, sex == "Male") -->
<!-- survey_females <- subset(survey, sex == "Female") -->
<!-- ``` -->

<!-- Note that we use the **label** for sex, not the underlying numeric value, as sex is a **factor**. -->

<!-- We can now create hisotgrams and boxplots of BMI for males and females separately. To place the graphs next to each other in a single figure, we can use the `par` function, which sets the *graphics parameters*. Essentially, we want to tell R to split a plot window into a matrix with *nr* rows and *nc* columns, and we fill the cells by rows (`mfrow`) or columns (`mfcols`). -->

<!-- For example, to plot four figures in a single plot, filled by rows, we use `par(mfrow=c(2,2))`. -->

<!-- When we are done plotting multiple graphs, we can reset the graphics parameters by submitting `par(mfrow=c(1,1))`. -->

<!-- ```{r fig.height=7} -->
<!-- # Set the graphics parameters to plot 2 rows and 2 columns: -->
<!-- par(mfrow = c(2, 2)) -->

<!-- # Specify each plot separately -->
<!-- hist(survey_males$bmi, xlab = "BMI (kg/m2)", main = "Males") -->
<!-- hist(survey_females$bmi, xlab = "BMI (kg/m2)", main = "Females") -->

<!-- boxplot(survey_males$bmi, ylab = "BMI (kg/m2)", main = "Males") -->
<!-- boxplot(survey_females$bmi, ylab = "BMI (kg/m2)", main = "Females") -->

<!-- # Reset graphics parameters -->
<!-- par(mfrow = c(1, 1)) -->
<!-- ``` -->

## Recoding data {#sec-recoding-data}

One task that is common in statistical computing is to recode variables. For example, we might want to group some categories of a categorical variable, or to present a continuous variable in a categorical way.

In this example, we can use the `pbc` data and recode age into age groups:

-   Less than 30
-   30 to less than 50
-   50 to less than 70
-   70 or older

The quickest way to recode a continuous variable into categories is to use the `cut` command which takes a continuous variable, and "cuts" it into groups based on the specified "cutpoints"

```{r}
pbc$agegroup <- cut(pbc$age,
    breaks = c(0, 30, 50, 70, 100)
)
```

Notice that some numbers need to be defined for the lowest (age=0) and highest (age=100) bounds: both a lower and upper limit must be defined for each group.

If we examine the new `agegroup` variable:

```{r}
summary(pbc$agegroup)
```

we see that each group has been labelled in the form of (a, b]. This notation is equivalent to: greater than a, and less than or equal to b. The `cut` function excludes the lower limit, but includes the upper limit. Our age groups have been defined to include the lower limit, and exclude the upper limit (for example, greater than or equal to 30 and less than 50).

We can specify this recoding using the `right=FALSE` option:

```{r}
pbc$agegroup <- cut(pbc$age,
    breaks = c(0, 30, 50, 70, 100),
    right = FALSE
)

summary(pbc$agegroup)
```

Finally, we can specify labels for the groups using the `labels` option:

```{r}
pbc$agegroup <- cut(pbc$age,
    breaks = c(0, 30, 50, 70, 100),
    right = FALSE,
    labels = c(
        "Less than 30", "30 to less than 50", 
        "50 to less than 70", "70 or more"
    )
)

summary(pbc$agegroup)
```

## Computing binomial probabilities using R {#sec-binom-r}

There are two R functions that we can use to calculate probabilities based on the binomial distribution: `dbinom` and `pbinom`:

-   `dbinom(x, size, prob)` gives the probability of obtaining `x` successes from `size` trials when the probability of a success on one trial is `prob`;
-   `pbinom(q, size, prob)` gives the probability of obtaining `q` **or fewer** successes from `size` trials when the probability of a success on one trial is `prob`;
-   `pbinom(q, size, prob, lower.tail=FALSE)` gives the probability of obtaining **more than** `q`successes from `size` trials when the probability of a success on one trial is `prob`.

To do the computation for part (a) in Worked Example 2.1, we will use the `dbinom` function with:

-   *x* is the number of successes, here, the number of smokers (i.e. k=3);
-   *size* is the number of trials (i.e. n=6);
-   and *prob* is probability of drawing a smoker from the population, which is 19.8% (i.e. p=0.198).

Replace each of these with the appropriate number into the formula:

```{r}
dbinom(x = 3, size = 6, prob = 0.198)
```

To calculate the upper tail of probability in part (b), we use the `pbinom(lower.tail=FALSE)` function. Note that the `pbinom(lower.tail=FALSE)` function **does not include `q`**, so to obtain 4 or more successes, we need to enter `q=3`:

```{r}
pbinom(q = 3, size = 6, prob = 0.198, lower.tail = FALSE)
```

For the lower tail for part (c), we use the `pbinom` function:

```{r}
pbinom(q = 2, size = 6, prob = 0.198)
```

