## Producing a one-way frequency table

The simplest way to summarise categorical variables is with a one-way frequency table. These are constructed using **Analyses \> Exploration**. We will illustrate this by summarising the variable `sex` from the `pbc.rds` data from the previous module.

![](img/mod02/jamovi/mod02-onefreq01.png)

jamovi has summarised `sex` here, just as we asked it to, however it has analysed `sex` as if it was a continuous variable. This is incorrect: `sex` is a categorical variable. This can be corrected by defining `sex` to be categorical within **Data \> Setup**:

1.  Select `sex`, then choose **Nominal** as the Measure type. jamovi now lists the levels of `sex` as 1 and 2. These should be replaced by the categories they represent.
2.  From the `mod01_pbc_info.txt` file, we see that 1 represents Male, and 2 represents Female. These labels can be added by typing in the appropriate cell. The completed screen should look like this:

![](img/mod02/jamovi/mod02-onefreq02.png)

Clicking back to the original summary of sex shows that jamovi is no longer treating `sex` as a continuous variable, but there is little output in the summary:

![](img/mod02/jamovi/mod02-onefreq03.png){width="30%"}

Click **Frequency tables** in the main Descriptives window to request the one-way frequency table:

![](img/mod02/jamovi/mod02-onefreq04.png)

## Producing a two-way frequency table

Two-way tables are constructed using **Analyses > Frequencies > Contingency Tables > Independent Samples**. Note that **both variables must be defined as Nominal variables**. As an example, to produce a two-way table of disease stage by sex:

![](img/mod02/jamovi/mod02-twofreq01.png)

**Ignore the output labelled Ï‡^2^ tests for now.**

Row or column percents can be requested in the **Cells** section. For example, to calculate the proportion of males within each stage of disease, we would request column percents:

![](img/mod02/jamovi/mod02-twofreq02.png)

## Creating bar charts for categorical data

Here we will create the bar chart shown in @fig-bar-1 using the `mod01_pbc.dta` dataset. The x-axis of this graph will be the stage of disease, and the y-axis will show the number of participants in each category.

Bar charts are created in the **Exploration** tab. We can summarise `stage`, and request a **Frequency table** in the usual way. To request a bar chart as well, tick **Bar plot** within the **Plots** section:

![](img/mod02/jamovi/mod02-barchart01.png)











## Checking your data for errors in R

Before you start describing and analysing your data, it is important to make sure that no errors have been made during the data entry process. Basically, you are looking for values that are outside the range of possible or plausible values for that variable.

If an error is found, the best method for correcting the error is to go back to the original data e.g. the hard copy questionnaire, to obtain the original value, entering the correct value into R If the original data is not available or the original data is also incorrect, the erroneous value is often excluded from the dataset.

For continuous variables, the easiest methods are to examine a boxplot and histogram. For example, a boxplot and histogram for the weight variable we just imported appear as:

<!-- ```{r} -->
<!-- hist(sample$weight, xlab = "Weight (kg)", main = "Histogram of 1000 weights") -->
<!-- boxplot(sample$weight, xlab = "Weight (kg)", main = "Boxplot of 1000 weights") -->
<!-- ``` -->

There is a clear outlying point shown in the boxplot. Although not obvious, the same point is shown in the histogram as a bar around 700 with a very short height.

We can identify any outlying observations in the dataset using the `subset` function. You will need to decide if these values are a data entry error or are biologically plausible. If an extreme value or "outlier", is biologically plausible, it should be included in all analyses.

For example, to list any observations from the `sample` dataset with a weight larger than 200:

<!-- ```{r} -->
<!-- subset(sample, weight > 200) -->
<!-- ``` -->

We see that there is a very high value of 700.2kg. A value as high as 700kg is likely to be a data entry error (e.g. error in entering an extra zero) and is not a plausible weight value. Here, **you should check your original data**.

You might find that the original weight was recorded in medical records as 70.2kg. You can change this in R by writing code.

**Note:** many statistical packages will allow you to view a spreadsheet version of your data and edit values in that spreadsheet. This is not best practice, as corrected observations may revert to their original values depending on whether the edited data have been saved or not. By using code-based recoding, the changes will be reproduced the next time the code is run.

We will use an `ifelse` statement to recode the incorrect weight of 700.2kg into 70.2kg. The form of the `ifelse` statement is as follows:

`ifelse(test, value_if_true, value_if_false)`

Our code will create a new column (called `weight_clean`) in the `sample` dataframe. We will test whether `weight` is equal to 700.2; if this is true, we will assign `weight_clean` to be 70.2, otherwise `weight_clean` will equal the value of `weight`.

Putting it all together:

<!-- ```{r} -->
<!-- sample$weight_clean <- ifelse(sample$weight == 700.2, 70.2, sample$weight) -->
<!-- ``` -->

**Note:** if an extreme value lies within the range of biological plausibility it should not be removed from analysis.

Once you have checked your data for errors, you are ready to start analysing your data.

### What on earth: == ?

In R, the test of equality is denoted by two equal signs: `==`. So we would use `==` to test whether an observation is equal to a certain value. Let's see an example:

```{r}
# Test whether 6 is equal to 6
6 == 6

# Test whether 6 is equal to 42
6 == 42
```

You can read the `==` as "is equal to". So the code `sample$weight == 700.2` is read as: "is the value of weight from the data frame sample equal to 700.2?". In our `ifelse` statement above, if this condition is true, we replace `weight` by 70.2; if it is false, we leave weight as is.

## Importing Excel data into R

Another common type of file that data are stored in is a Microsoft Excel file (.xls or .xlsx). In this demonstration, we will import a selection of records from a large health survey, stored in the file `mod02_health_survey.xlsx`.

The health survey data contains 1140 records, comprising:

-   sex: 1 = respondent identifies as male; 2 = respondent identifies as female
-   height: height in meters
-   weight: weight in kilograms

To import data from Microsoft Excel, we can use the `read_excel()` function in the `readxl` package.

```{r}
library(readxl)

survey <- read_excel("data/examples/mod02_health_survey.xlsx")
summary(survey)
```

We can see that sex has been entered as a numeric variable. We should transform it into a factor so that we can assign labels to each category:

```{r}
survey$sex <- factor(survey$sex, level = c(1, 2), labels = c("Male", "Female"))

summary(survey$sex)
```

We also note that height looks like it has been entered as meters, and weight as kilograms.

## Generating new variables

Our health survey data contains information on height and weight. We often summarise body size using BMI: body mass index which is calculated as: $\frac{\text{weight (kg)}}{(\text{height (m)})^2}$

We can create a new column in our data frame in many ways, such as using the following approach:

`dataframe$new_column <- <formula>`

For example:

```{r}
survey$bmi <- survey$weight / (survey$height^2)
```

We should check the construction of the new variable by examining some records. The `head()` and `tail()` functions list the first and last 6 records in any dataset. We can also examine a histogram and boxplot:

```{r}
head(survey)
tail(survey)

hist(survey$bmi)
boxplot(survey$bmi)
```

In the general population, BMI ranges between about 15 to 30. It appears that BMI has been correctly generated in this example. We should investigate the very low and some of the very high values of BMI, but this will be left for another time.

## Summarising data by another variable

We will often want to calculate the same summary statistics by another variable. For example, we might want to calculate summary statistics for BMI for males and females separately. We can do this in in the `descriptives` function by defining sex as a `splitBy` variable:

```{r}
library(jmv)
descriptives(data = survey, vars = bmi, splitBy = sex)
```

## Summarising a single column of data

In Module 1, we started with a very simple analysis: reading in six ages, and them using `summary()` to calculate descriptive statistics. We then went on to use the `decriptives()` function in the `jmv` package as more flexible way of calculating descriptive statistics. Let's revisit this analysis:

```{r message=FALSE, warning=FALSE, include=FALSE}
detach(package:jmv, unload = TRUE)
```

```{r, error=TRUE}
# Author: Timothy Dobbins
# Date: 5 April 2022
# Purpose: My first R script
library(jmv)

age <- c(20, 25, 23, 29, 21, 27)

# Use "summary" to obtain descriptive statistics
summary(age)

# Use the "descriptives" function from jmv to obtain descriptive statistics
descriptives(age)
```

The `summary()` function has worked correctly, but the `descriptives()` function has given an error: `Error: Argument 'data' must be a data frame`. What on earth is going on here?

The error gives us a clue here - the `descriptives()` function requires a data frame for analysis. We have provided the object `age`: a **vector**. As we saw in @sec-data-structures, a vector is a single column of data, while a data frame is a collection of columns.

In order to summarise a vector using the `descriptives()` function, we must first convert the vector into a data frame using `as.data.frame()`. For example:

```{r}
# Author: Timothy Dobbins
# Date: 5 April 2024
# Purpose: My first R script
library(jmv)

age <- c(20, 25, 23, 29, 21, 27)

# Use "summary" to obtain descriptive statistics
summary(age)

# Create a new data frame from the vector age:

age_df <- as.data.frame(age)

# Use "descriptives" to obtain descriptive statistics for age_df
descriptives(age_df)
```

## Plotting data by another variable

Unfortunately, it is not straight-forward to create separate plots for every level of another variable. We will demonstrate by plotting BMI by sex using our health survey data.

The following steps are not the most efficient way of doing this, but are easy to follow and understand. We first begin by creating two new data frames, for males and females separately, using the `subset()` function:

```{r}
survey_males <- subset(survey, sex == "Male")
survey_females <- subset(survey, sex == "Female")
```

Note that we use the **label** for sex, not the underlying numeric value, as sex is a **factor**.

We can now create hisotgrams and boxplots of BMI for males and females separately. To place the graphs next to each other in a single figure, we can use the `par` function, which sets the *graphics parameters*. Essentially, we want to tell R to split a plot window into a matrix with *nr* rows and *nc* columns, and we fill the cells by rows (`mfrow`) or columns (`mfcols`).

For example, to plot four figures in a single plot, filled by rows, we use `par(mfrow=c(2,2))`.

When we are done plotting multiple graphs, we can reset the graphics parameters by submitting `par(mfrow=c(1,1))`.

```{r fig.height=7}
# Set the graphics parameters to plot 2 rows and 2 columns:
par(mfrow = c(2, 2))

# Specify each plot separately
hist(survey_males$bmi, xlab = "BMI (kg/m2)", main = "Males")
hist(survey_females$bmi, xlab = "BMI (kg/m2)", main = "Females")

boxplot(survey_males$bmi, ylab = "BMI (kg/m2)", main = "Males")
boxplot(survey_females$bmi, ylab = "BMI (kg/m2)", main = "Females")

# Reset graphics parameters
par(mfrow = c(1, 1))
```

## Recoding data {#sec-recoding-data}

One task that is common in statistical computing is to recode variables. For example, we might want to group some categories of a categorical variable, or to present a continuous variable in a categorical way.

In this example, we can recode BMI into the following categories as suggested by the World Health Organisation \[footnote\]:

-   Underweight: BMI \< 18.5
-   Normal weight: 18.5 $\le$ BMI \< 25
-   Pre-obesity: 25 $\le$ BMI \< 30
-   Obesity Class I: 30 $\le$ BMI \< 35
-   Obesity Class II: 35 $\le$ BMI \< 40
-   Obesity Class III: BMI $\ge$ 40

The quickest way to recode a continuous variable into categories is to use the `cut` command which takes a continuous variable, and "cuts" it into groups based on the specified "cutpoints"

```{r}
survey$bmi_cat <- cut(survey$bmi,
    breaks = c(0, 18.5, 25, 30, 35, 40, 100)
)
```

Notice that lower (BMI=0) and upper (BMI=100) bounds have been specified, as both a lower and upper limit must be defined for each group.

If we examine the new `bmi_cat` variable:

```{r}
summary(survey$bmi_cat)
```

we see that each group has been labelled (a, b\]. This notation is equivalent to: greater than a, and less than or equal to b. The `cut` function excludes the lower limit, but includes the upper limit. Our BMI ranges have been defined to include the lower limit, and exclude the upper limit (for example, greater than or equal to 30 and less than 35).

We can specify this recoding using the `right=FALSE` option:

```{r}
survey$bmi_cat <- cut(survey$bmi,
    breaks = c(0, 18.5, 25, 30, 35, 40, 100),
    right = FALSE
)

summary(survey$bmi_cat)
```

Finally, we can specify labels for the groups using the `labels` option:

```{r}
survey$bmi_cat <- cut(survey$bmi,
    breaks = c(0, 18.5, 25, 30, 35, 40, 100),
    right = FALSE,
    labels = c(
        "Underweight", "Normal", "Pre-obesity",
        "Obesity Class I", "Obesity Class II",
        "Obesity Class III"
    )
)

summary(survey$bmi_cat)
```

## Computing binomial probabilities

jamovi does not have a point-and-click method for computing probabilities from a binomial distribution. Here, instructions are provided for using a third-party applet. This Binomial Distribution Applet has been posted at https://homepage.stat.uiowa.edu/~mbognar/applets/bin.html, and provides a simple and intuitive way to compute probabilities from a binomial distribution. 

The applet requires three pieces of information:

- $/n$: the number of binary trials being considered
- $/p$: the probability of "success" in each trial
- $x$: the number of success we are interested in

We also need to consider whether we are interested in the probability being equal to, greater than, or less than x.

To do the computation for part (a) in Worked Example 2.1:

-   *x* is the number of successes, here, the number of smokers (i.e. x=3);
-   *n* is the number of trials (i.e. n=6);
-   and *p* is probability of drawing a smoker from the population, which is 19.8% (i.e. p=0.198).

Replace each of these with the appropriate number into the applet:

![](img/mod02/jamovi/mod02-bin-01.png)

To calculate the probability of at least 4 smokers in part (b), we change the drop-down to "P(Xâ‰¥x)", and x to be equal to 4:

![](img/mod02/jamovi/mod02-bin-02.png)

To calculate the probability of at most 2 smokers part (c), we we change the drop-down to "P(Xâ‰¤x)", and x to be equal to 2:

![](img/mod02/jamovi/mod02-bin-03.png)
